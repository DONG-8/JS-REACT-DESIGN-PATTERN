# 1장 - 디자인 패턴

## 1.2 패턴이란 
패턴이란 소프트웨어 설계에서 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿 

#### 디자인 패턴이 개발자에게 유용한 이유 
- 검증 : 패턴은 개발자들의 경험, 오랜 시간 검증된 접근 방식
- 쉬운 재사용 : 패턴은 독창적인 솔루션을 제공, 사용자 요구에 맞춰 적용 가능
- 알아보기 쉬움 : 정해진 구조와 공통 표현을 사용해 솔루션 제공 가능 

- 실수를 줄여 큰 문제 방지 가능 
- 특정 문제에 국한되지 않은 종합적인 해결책 제시 
- 반복을  피해 코드양 감소 

- 공통된 어휘를 사용해 의사소통 원할
- 인기있는 패턴을 통해 커뮤니티의 선순환 유발 



# 2장 - 패턴성 검증 , 프로토 패턴 - 3가지 법칙

이 장에서는 프로토 패턴이 패턴성 검증을 거치고 세가지 법칙을 충족해 디자인 패턴으로 인정받는 과정을 설명한다.

## 2.1 프로토 패턴?
'패턴성' 검증을 모두 통과하지 않은 미숙한 패턴
개인의 작업물로 인정할 순 있지만, 커뮤니티의 충분한 검토를 받아야 한다. 

## 2.2 좋은 패턴이란? 
- 특정 문제를 해결할 수 있다. 
- 명쾌한 해결책이 없다. - 해결책을 간접적으로 제공해 설계 문제를 풀어낼 수 있다.
- 확실한 기능만을 말한다. - 설명에 쓰인대로 작동해야 한다.
- 관계를 설명한다. - 코드와의 관계를 나타내는 심층 구조와 메커니즘을 설명해야 한다. 

## 2.3 세가지 법칙
좋은 패턴이 되기 위해서 반복되는 현상에서 지속적으로 사용되어야 한다.
반복성을 입증하기 위해 세가지 법칙을 따라야 한다.

- 목적 적합성 - 좋은 패턴을 어떻게 판단하는지?
- 유용성 - 좋은 패턴이라고 할 수 있는 이유 ?
- 적용 가능성 - 넓은 적용 범위를 가지고 있어 패턴이 될 가치를 확인 

# 3장 - 패턴 구조화 및 작성
개발자들이 디자인 패턴을 올바르게 이해하고 채택할 수 있도록, 상황, 요구사항 등 적절한 예제가 충분히 제공되어야 한다. 
이번 장에서는 어떻게 패턴을 구조화하고 작성하는지 알아본다. 

## 3.1 디자인 패턴의 구조
패턴의 작성자는 패턴의 설계, 구현 방법 및 목적을 설명해야 한다.
다음의 관계성을 생각해 규칙의 형태로 패턴을 제시한다. 
- 컨텍스트 - 패턴이 적용되는 상황
- 집중 목표 - 패턴을 적용할 때 고려해야 하는 목표 
- 구성 - 제시된 상황과 고려해야 하는 점들을 해결하는 구성 

| 디자인 패턴은 다음의 요소를 포함해야 한다.
1. 이름 - 패턴의 목적을 드러내는 이름
2. 설명 - 패턴이 무엇을 해결할 수 있는지 설명 
3. 컨텍스트 개요 - 패턴이 사용자의 요구에 부합하는지 확인
4. 문제 제시 - 패턴을 만든 의도를 알 수 있게 문제 제시 
5. 해결 방법 - 이해하기 쉬운 단계와 개념을 통해 어떻게 해결되는지 설명 
- 설계 내용, 구현 방법, 시각적 설명, 예시, 필수 연계, 관계성, 알려진 용도 ...

# 4장 - 안티 패턴
신속한 구현을 위해 임시방편을 선택하기도 한다.
반면교사로 활용하는 나쁜 디자인 패턴 

**JS 에서의 안티패턴**
- 전역 변수를 오염시키기
- eval 로 실행시키기
- Object 클래서의 프로토타입을 수정하기
- js 를 인라인으로 사용해 유연성 떨어뜨리기


# 5. 최신 자바스크립트 기능 & 문법 

모듈형 자바스크립트는 애플리케이션을 모듈이라는 단위로 쪼갤 수 있다. 
따라서 애플리케이션은 여러개의 중첩된 모듈로 구성되게 할 수 있다. 

이렇게 이루어진 느슨한 결합으로 의존성을 낮추어 애플리케이션의 유지보수를 용이하게 만든다. 

모듈형 자바스크립트는 이렇게 표준이 되었다. 

## 5.2 모듈 가져오기와 내보내기 
- import = 의존 모듈 가져오기 
- export = 다른 모듈에서 사용할 모듈 내보내기
```js
export const backer = {
  bake(item){
    console.log(`bake ${item}!`)
  }
}
...
import baker from "/modules/backer.js"
backer.bake("cake")
```

여러개의 모듈을 하나로 정리하여 하나로 내보내기 
```js
const backer = {...}
const pastryChef = {...}
const assistent = {...}
export {backer, pastryChef,assistent}
...
import {backer,assistent} from "modules/staff.js"
```


스크립트 태그에서 type 에 모듈을 명시해 브라우저에게 알릴 수 있다. 
```html
<script type="module" src="main.js"></script>
```

**모듈을 객체로 가져오기** 
```js
impoprt * as Staff from "modules/staff.js"
Staff.backer("cake")
```

외부 소스로부터 모듈 가져오기 (정적)
```js
import {backer} from "https://example.com/modules/"
```


## 5.6 동적으로 모듈 가져오기
위의 상황들은 정적으로 모듈을 가져오는 방법(static import)

이 내용들은 실행하기 전에 먼저 모듈을 다운로드하고 실행해야 하기 때문에 초기 페이지 로드 시 많은 코드를 미리 로드해야 하므로 성능에 문제가 생길 수도 있다. 

모듈을 초기에 로드하기 보다 필요 시점에 로드하는게 필요할 수도 있다. 
예를 들어, 클릭시 로드하게 하는 방법 
- lazy-loading 

동적 가져오기는 함수와 비슷한 형태 
`import (url)` 로 사용하며, 프로미스 객체로 반환한다.
이 객체는 모듈 자체와 모든 모듈 의존성을 가져온 후, 인스턴스화 하고 평가한 뒤에 만들어진다.

동적 가져오기 (dynamic import)는 모듈이 사용될 때만 실행된다. 

#### 5.6.1 클릭시 가져오기 

```js
butn.addEventListner("click",(e)=>{
  import ("/modules/staff.js")
    .then((module)=>{
        // 가져온 모듈 사용하기 
        module.backer("bread")
    })
})
```

#### 5.6.2 화면에 보이면 가져오기 
스크롤을 내려 화면에 보이면 구현하는 것도 좋은 방법
모듈을 지연로딩으로 구현 
`IntersectionObservcer API ` 을 이용해 컴포넌트가 화면에 보이는지 감지 

## 5.8 모듈의 장점
- 한번만 실행된다. - 의존성 트리의 가장 내부에 위치한 모듈이 먼저 실행 
- 자동으로 지연 로드 - 즉시 로드되지 않기 위해 나머지는 defer 속성이 필요하지만 모듈은 자동으로 지연 로딩된다. 
- 유지보수 간편 - 독립적인 코드 조각으로 관리되어 재사용 용이 
- 네임 스페이스 제공 - 변수와 상수를 위한 개별 공간 마련
- 사용하지 않는 코드 제거 가능 - 모듈을 통해 코드를 가져오면 번들러를 통해 트리쉐이킹 가능


## 5.9 클래스
ES2015+ 에는 클래스가 추가되었다. 
자바스크립트의 클래스는 프로토타입을 기반으로 하고 있고, 사용 전 미리 정의해야 한다. 
모듈과 클래스의 차이점은 모듈은 가져오기/내보내기를 통해, 클래스는 class 키워드를 통해 정의할 수 있다는 것

- 자기 상속 패턴을 사용할 때 유리 - `super`


##### 비공개 멤버
클래스 멤버는 기본적으로 공개 상태이고, #(해시)를 붙여 비공개 멤버로 변경 가능 
```js
class CookiePrivate{
  #privateMethod(){
    return "hi cookie"
  }
}
```


##### static
static 키워드를 통해 정적 메서드와 프로퍼티 정의 가능
정적 멤버는 클래스를 초기화하지 않고도 사용 가능. 
주로 어떠한 설정이나 캐시 데이터 보관용으로 사용 