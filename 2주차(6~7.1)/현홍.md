# 6장 - 디자인 패턴의 유형

## 6.1 배경

디자인 패턴은 공통 설계 구조의 핵심 요소를 이름 짓고 추상화하여 재사용할 수 있는 객체 지향 설계를 만드는 데 유용한 역할을 한다.

#### 디자인 패턴의 유형

디자인 패턴은 어떤 문제를 해결하냐에 따라 세가지 유형으로 구분

- 생성 패턴
- 구조 패턴
- 행위 패턴

## 6.2 생성 패턴

주어진 상황에 적합한 객체를 생성하는 방법에 중점
일반적인 객체 생성은 프로젝트의 복잡성을 증가시킬 수 있어 이 과정을 제어하여 문제를 해결

팩토리 : 인터페이스를 기반으로 여러 파생 클래스 생성
추상 팩토리 : 구체적인 내부 구현 없이 여러 클래스가 상속받아 사용하는 인스턴스 생성
빌더 : 객체를 생성하는 부분과 내부 구현을 분리하여 항상 같은 객체 생성
프로토타입 : 복사/복제에 사용되는 초기화된 인스턴스
싱글톤 : 전역에서 접근 가능한 하나만의 인스턴스를 가진 클래스

## 6.3 구조 패턴

객체의 구성과 각 객체 간의 관계를 인식하는 방법에 중점
시스템의 어느 부분을 변경하더라도 다른 부분에 영향이 가지 않게 돕는다

어댑터 : 호환되지 않는 인터페이스가 상호작용하도록 클래스 매치
브릿지 : 객체의 인터페이스와 구현을 분리하여 독립적으로 구성
컴포지트 : 단순히 합친 상태 이상의 효율을 내는 구조
데코레이터 : 객체에 새로운 프로세스를 동적으로 추가
퍼사드 : 복잡한 부분을 숨기는 클래스
플라이웨이트 : 여러 객체에 공통 상태를 공유하는 세분화된 인스턴스
프록시 : 실제 객체를 대신하는 대체 객체

## 6.4 행위 패턴

시스템 내의 객체 간 커뮤니케이션을 개선/ 간소화 하는 방법에 중점
객체 간의 공통적인 커뮤니케이션 패턴을 감지하고 책임을 분배

이터레이터, 중재자, 관찰자, 방문자
인터프리터 : 언어의 목적과 문법에 일치하는 언어 요소를 포함시키는 법
템플릿 메서드 : 상위 클래스에서 기본 구조를 생성한 다음 하위 클래스에서 구체적으로 정의
책임 연쇄 : 요청을 처리할 수 있는 객체를 찾기 위해 체인 간에 요청을 전달
이터레이터 : 내부 구조를 모른채 요소에 순차적으로 접근

# 7. 자바스크립트 디자인 패턴 (~7.13)

## 7.2 생성자 패턴

객체를 생성하는 방법

생성자 (constructor) 는 객체가 새로 만들어진 뒤 초기화하는 데에 사용되는 메서드

#### 7.2.1 객체 생성 방법

1. `const newObject = {}`

2. `const newObject = Object.create(Object.prototype)`

3. `const newObject = new Object()`

값 할당하기

1. `newObject.somekey = "hello"`
2. `newObject["somekey"] = "heelo"`
3. `Object.defineProperty(newObject,"somekey",{value:"heelo",writable:true, enumerable:true, configurable:true})`

#### 7.2.2 생성자의 기본 특징

클래스는 새 객체를 초기화하는 constructor 라는 이름의 메서드를 가지고 있어야 한다.
또한 new 키워드는 생성자를 호출할 수 있으며, 생성자 내부에서 사용된 this 키워드는 새로 생성된 해당 객체를 가리킨다.

#### 7.2.3 프로토타입을 가진 생성자

자바스크립트의 프로토타입 객체는 함수나 클래스 등 특정 객체의 모든 인스턴스 내에 공통 매서드를 쉽게 정의할 수 있게 한다.
생성자를 통해 객체를 생성하면 생성자의 프로토타입 객체에 속한 속성을 새 객체에서도 활용할 수 있다.

```js
Car.prototype.toString = () => {
  return "hi";
};
```

이렇게 선언하면 Car 생성자로 객체를 생성할때 함수를 매번 새로 정의하지 않고, 동일한 함수를 공유할 수 있다.

## 7.3 모듈 패턴

모듈은 애플리케이션 아케텍쳐의 핵심 구성 요소이며, 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는데 효과적으로 활용된다.

#### 객체 리터럴

객체는 중괄호 안에서 쉼표로 구분하여 정의하는 법

```js
const module = {
  name: "hi",
  age: 15,
  say: () => {
    console.log("HI");
  },
};
```

#### 모듈패턴

모듈 패턴은 클래스의 캡슐화를 위해 고안되었다.
개발자들은 모듈을 사용해 객체, 함수 변수 등을 다른파일에 내보내거나 가져오기가 가능했다.
이를 통해 서로 다른 모듈 간 클래스, 함수명 충돌도 방지가 가능하다.

##### 비공개

모듈 패턴은 클로저를 이용해 비공개 상태와 구성을 캡슐화 한다.
전역 스코프로의 유출을 방지하고 인터페이스 충돌도 방지한다.

이를통해 사용할 부분만 노출하고, 핵심 작업은 보호하는 구조를 구축할 수 있다.
대부분의 모듈은 객체를 내보낸다.

장점

- 모듈 사이의 의존성 관리 용이
- 전역 요소를 원하는 만큼 넘겨줘 코드의 유지보수를 용이하게 한다.
- 비공개를 지원한다.
- export 를 이용해 원하는 값만 접근가능하게 할 수 있다.

##### WeakMap

약한 참조를 가진 키-값의 쌍으로 이루어진 집합체
weakmap은 키가 약하게 유지되는 맵
참조되지 않는 키는 가비지컬렉션 대상이 되어버린다.

## 7.4 노출 패턴

객체 리터럴 표기법을 사용해 요소를 공개하는 것이 맘에 들지 않아 모든 변수와 함수를 비공개 스코프에 정의하고 공개하고 싶은 부분만 포인터를 통해 접근할 수 있게 해주는 패턴이 탄생

ES2015+ 에서는 모듈 스코프 내 정의된 함수와 변수는 비공개 처리

- 코드의 일관성 유지
- 모듈의 가장 아래 위치한 공개 객체를 통해 가독성 향상 가능

단점
비공개 함수를 참조하는 공개함수를 수정할 수 없다.

## 7.5 싱글톤 패턴

클래스의 인스턴스가 하나만 존재하도록 하는 패턴
싱글톤 패턴은 초기화를 지연시킬 수 있다.
싱글톤은 객체나 클래스가 아닌 구조이기 때문이다.

싱글톤 구현하기

```js
let instance;

class MySingletone {
  constructor() {
    if (!instance) {
      this.publicProperty = "Hi!";
      instance = this;
    }
    return instance;
  }
}
```

- 클래스의 인스턴스는 정확히 하나만 있어야 하며, 눈에 잘 보이는 곳에 위치시켜 접근을 용이하게 해야한다.
- 싱글톤의 인스턴스는 서브클래싱을 통해서만 확장할 수 있고, 코드의 수정 없이 확장된 인스턴스를 사용할 수 있어야 한다.

싱글톤은 분명 유용한 방법이다 하지만, js 는 객체를 직접적으로 생성할 수 있다.
따라서 싱글톤 클래스를 만드는 대신에 직접 객체 하나를 생성할 수도 있다는 뜻이된다.

싱글톤이 사용되면 전역 범위에 걸쳐 필요한 데이터를 저장하기 때문에 복잡해질 수 있다.

#### 리액트의 상태 관리

리액트를 이용하면 싱글톤 대신 상태 관리를 이용하는 것이 좋다.
이러한 상태 관리 도구는 변경 불가능한 읽기 전용 상태를 제공한다.

## 7.6 프로토타입 패턴
